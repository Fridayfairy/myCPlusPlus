# :: 范围解析运算符那些事

## 关于作者：

个人公众号：

![](../img/wechat.jpg)

- 全局作用域符（::name）：用于类型名称（类、类成员、成员函数、变量等）前，表示作用域为全局命名空间
- 类作用域符（class::name）：用于表示指定类型的作用域范围是具体某个类的
- 命名空间作用域符（namespace::name）:用于表示指定类型的作用域范围是具体某个命名空间的

具体代码见：[maohao.cpp](maohao.cpp)

如果是在maohao.cpp中的main函数里，使用extern int x定义了变量x，可以在another.cpp中访问吗



好的，作为一名资深程序员，我来详细解答你的这个问题。

核心答案是：**不能访问。**

**详细解读：**

问题的关键在于理解 C++ 中**作用域（Scope）**和**链接性（Linkage）**的区别。

1.  **作用域 (Scope):**
    作用域决定了变量或函数的名称在代码的哪些区域是可见和有效的。
    *   **全局作用域:** 在所有函数和类的外部声明的变量或函数，其名称在整个文件（或如果具有外部链接，则在整个程序）中都是可见的。
    *   **类作用域:** 类成员的名称仅在类定义内部和通过类对象、指针或引用访问时可见。
    *   **局部作用域 (或块作用域):** 在函数内部、循环、if 语句等代码块内部声明的变量，其名称仅在声明它们的块及其嵌套块中可见。

2.  **链接性 (Linkage):**
    链接性决定了变量或函数的名称是否可以在程序的多个编译单元（`.cpp` 文件）之间共享。
    *   **外部链接 (External Linkage):** 名称可以在多个编译单元中被引用。全局非 `const` 变量、非 `static` 函数默认具有外部链接。
    *   **内部链接 (Internal Linkage):** 名称仅在其所在的编译单元内部可见。全局 `static` 变量、`static` 函数、匿名命名空间内的名称默认具有内部链接。
    *   **无链接 (No Linkage):** 名称仅在其作用域内可见，不能在任何其他地方被引用。局部变量（函数内部声明的）默认具有无链接。

现在来看你的情况：

```c++
// 在 maohao.cpp 文件中
int main() {
  // 在函数内部声明变量 x
  extern int x;
  // ... main 函数的其他代码
}
```

当你把 `extern int x;` 写在 `main` 函数内部时：

1.  `x` 被声明在 `main` 函数的局部作用域内。这意味着 `x` 的名称**只在 `main` 函数的花括号 `{}` 内部是可见和有效的**。
2.  `extern` 关键字确实影响了 `x` 的链接性（虽然对于局部变量使用 `extern` 不常见，且通常用于指代具有更广阔作用域的同名变量，但即使如此，它也不会改变局部变量的基本作用域规则）。然而，**链接性不改变作用域**。无论 `x` 是否具有外部链接（即使它指向了一个在别处定义的全局 `x`），你在 `main` 函数内部声明的这个 `x` 的名字仍然只在 `main` 函数内部有效。

**结论：**

由于 `x` 被声明在 `main` 函数的局部作用域内，它的作用范围仅限于 `main` 函数体内。`another.cpp` 是一个独立的编译单元，无法“看到”或访问 `maohao.cpp` 中 `main` 函数内部的任何局部变量，无论它们是否使用 `extern` 声明。

如果你想在 `another.cpp` 中访问一个变量，那个变量必须具有**全局作用域**（或者是一个类的静态成员，因为静态成员也存储在全局/静态数据区）并且具有**外部链接**。然后，在 `another.cpp` 中通过 `extern` 声明来引用它。
