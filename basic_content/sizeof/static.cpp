/**
 * @file static.cpp
 * @brief 静态数据成员
 * 静态数据成员被编译器放在程序的一个global data
 * members中，它是类的一个数据成员，但不影响类的大小。不管这个类产生了多少个实例，还是派生了多少新的类，静态数据成员只有一个实例。静态数据成员，一旦被声明，就已经存在。
 * @author 光城
 * @version v1
 * @date 2019-07-21
 */

#include <iostream>
using namespace std;
class A {
public:
  char b; // 1
  virtual void fun(){}; // 8 vptr
  static int c; // 4
  static int d; // 4
  static int f; // 4
};

int main() {

  /**
   * @brief 16  字节对齐、静态变量不影响类的大小、vptr指针=8
virtual 关键字使得这个函数成为虚函数，这是实现运行时多态的基础。
一个类只要包含一个或多个虚函数，该类的对象就会包含一个虚指针 (vptr)。
这个 vptr 通常是对象的第一个成员（从内存布局上看），
它指向该类对应的虚表 (vtable)。虚表是一个函数指针数组，存储了该类中虚函数的地址。
虚函数本身的代码并不存储在对象中，只存储指向虚表的指针 (vptr)。
vptr 的大小取决于系统架构，在 64 位系统上通常是 8 字节。
   */
  cout << sizeof(A) << endl; // 16
  cout << sizeof(A::b) << endl;
  cout << sizeof(A::c) << endl;
  cout << sizeof(A::d) << endl;
  cout << sizeof(A::f) << endl;

  return 0;
}

/*



好的，没问题。作为一名资深程序员，我来为你详细解读一下这段 C++ 代码 `static.cpp` 的语法，并着重分析类 `A` 的字节占用情况。

文件路径：`workspace/cocobooks/CPlusPlusThings/basic_content/sizeof/static.cpp`

**整体概览：**

这段代码定义了一个简单的类 `A`，其中包含一个非静态成员变量、一个虚函数和三个静态成员变量。代码的核心目的是通过 `sizeof` 运算符来展示这些不同类型的成员如何影响或不影响类对象的大小。文件开头的注释也很好地解释了静态数据成员的特性。

**逐行和逐概念分析：**

1.  **文件头部注释：**
    *   解释了代码的主要内容：静态数据成员（Static Data Members）。
    *   阐述了静态数据成员的关键特性：
        *   被编译器放在程序的全局数据段 (`global data members`)。
        *   它是类的一个数据成员，但**不影响**类（的**对象**）的大小。
        *   无论创建多少类实例或派生多少新类，静态数据成员**只有一个实例**。
        *   静态数据成员一旦被声明，其存储空间就已经存在（尽管其定义和初始化通常在类外部）。
    *   提供了作者和日期信息。

2.  **头文件与命名空间：**
    *   `#include <iostream>`: 包含了标准的输入输出流库，用于使用 `std::cout` 和 `std::endl`。
    *   `using namespace std;`: 引入了 `std` 命名空间，方便使用标准库组件。

3.  **类 `A` 的定义：**
    *   `class A { ... };`: 定义了一个名为 `A` 的类。
    *   `public:`: 指定其后的成员是公共的，可以在类外部访问。
    *   `char b;`: 这是一个**非静态成员变量**。每个 `A` 类的对象都会拥有自己的一个 `char` 类型的 `b` 副本。`char` 类型通常占用 1 字节。
    *   `virtual void fun(){};`: 这是一个**虚成员函数**。
        *   `virtual` 关键字使得这个函数成为虚函数，这是实现运行时多态的基础。
        *   一个类只要包含一个或多个虚函数，该类的对象就会包含一个**虚指针 (vptr)**。这个 vptr 通常是对象的第一个成员（从内存布局上看），它指向该类对应的**虚表 (vtable)**。虚表是一个函数指针数组，存储了该类中虚函数的地址。
        *   虚函数本身的代码并不存储在对象中，只存储指向虚表的指针 (vptr)。vptr 的大小取决于系统架构，在 64 位系统上通常是 8 字节。
    *   `static int c;`: 这是一个**静态成员变量**。`static` 关键字意味着 `c` 属于类 `A` 本身，而不是类 `A` 的某个特定对象。所有 `A` 类的对象共享同一个 `c`。它存储在程序的全局/静态数据段，**不占用 `A` 类对象的内存空间**。`int` 类型通常占用 4 字节。
    *   `static int d;`: 另一个静态成员变量，特性同 `c`。
    *   `static int f;`: 第三个静态成员变量，特性同 `c` 和 `d`。
    *   **注意：** 静态成员变量需要在类定义之外进行定义和初始化，例如在 `.cpp` 文件中写 `int A::c = 0;`。这个例子中只声明了静态成员，没有给出定义和初始化，但在计算 `sizeof` 时，这不影响类对象的大小计算。

4.  **`main` 函数：**
    *   `int main() { ... }`: 程序的入口点。
    *   `cout << sizeof(A) << endl;`: 计算并打印类 `A` 的**对象**的大小。这是代码中最关键的输出。
    *   `cout << sizeof(A::b) << endl;`: 计算并打印静态访问成员 `b` 的类型大小。`A::b` 是对成员 `b` 的引用，`sizeof(A::b)` 实际上等同于 `sizeof(char)`。
    *   `cout << sizeof(A::c) << endl;`: 计算并打印静态访问成员 `c` 的类型大小。`A::c` 是对静态成员 `c` 的引用，`sizeof(A::c)` 等同于 `sizeof(int)`。
    *   `cout << sizeof(A::d) << endl;`: 等同于 `sizeof(A::c)`，打印 `sizeof(int)`。
    *   `cout << sizeof(A::f) << endl;`: 等同于 `sizeof(A::c)`，打印 `sizeof(int)`。
    *   **重要区别：** `sizeof(A)` 是计算**类的一个对象**需要多少内存，而 `sizeof(A::member)` 是计算**成员本身的类型**需要多少内存。对于非静态成员，成员类型的大小会影响对象总大小；对于静态成员，成员类型的大小与对象大小无关。

**类 `A` 的字节占用情况深度分析：**

根据上面的分析和文件注释提示的 64 位系统环境：

1.  **非静态成员变量 `char b;`：** 占用 1 字节。
2.  **虚函数 `virtual void fun(){};`：** 导致类 `A` 的对象中含有一个虚指针 (vptr)。在 64 位系统上，一个指针通常占用 8 字节。
3.  **静态成员变量 `static int c, d, f;`：** 这三个静态成员**不存储在类 `A` 的对象中**。它们存储在程序的全局数据段，所有 `A` 对象共享这三个变量。因此，它们的大小（每个 `int` 4 字节）**不计入 `sizeof(A)`**。

4.  **内存对齐 (Memory Alignment) 和填充 (Padding)：**
    *   为了提高内存访问效率，编译器会按照特定的规则对成员进行对齐。通常，一个数据类型需要存储在其自身大小的整数倍的内存地址上（或者系统架构规定的更严格的对齐）。
    *   在这个类 `A` 中，有一个 1 字节的 `char` 和一个 8 字节的 vptr。
    *   在 64 位系统上，默认对齐通常是 8 字节。vptr（8 字节）本身需要 8 字节对齐。
    *   类对象的总大小通常是其最大对齐要求的整数倍（在这里是 8 字节）。
    *   对象布局可能如下（实际布局取决于编译器，但遵循一定规则）：
        *   vptr (8 bytes)
        *   `char b` (1 byte)
        *   Padding (7 bytes) - 用于填充，使得总大小成为 8 的倍数，且下一个对象的 vptr 也能从 8 字节边界开始。
    *   总大小 = 8 (vptr) + 1 (`char b`) + 7 (Padding) = 16 字节。
    *   这个计算结果与代码中 `sizeof(A)` 打印出 `16` 相符，也印证了文件注释中提到的 "16 字节对齐、静态变量不影响类的大小、vptr指针=8"。

5.  **`sizeof(A::b)`, `sizeof(A::c)`, `sizeof(A::d)`, `sizeof(A::f)`：**
    *   `sizeof(A::b)` 等同于 `sizeof(char)`，输出 1。
    *   `sizeof(A::c)` 等同于 `sizeof(int)`，输出 4。
    *   `sizeof(A::d)` 等同于 `sizeof(int)`，输出 4。
    *   `sizeof(A::f)` 等同于 `sizeof(int)`，输出 4。
    *   这些 `sizeof` 操作符用于获取成员**类型**的大小，而不是成员在对象中的偏移或是否占用对象空间。对于静态成员，它们只是告诉你 `static int` 类型的大小是 4 字节，这与类对象的大小无关。

**总结：**

这段代码的核心在于演示了 C++ 中类对象的内存布局和大小计算规则：

*   类对象的大小由其**非静态成员变量**和**虚指针 (vptr)** 的总大小，考虑**内存对齐和填充**后决定。
*   **静态成员变量**不存储在类对象中，它们存储在独立的全局/静态数据区域，因此**不影响**类对象的大小。
*   虚函数本身不增加对象的大小，但它们的存在会导致对象包含一个虚指针 (vptr)，而 vptr 会增加对象的大小（通常是 4 或 8 字节）。
*   `sizeof(ClassName)` 计算的是类**对象**的大小，而 `sizeof(ClassName::member)` 计算的是成员**类型**的大小。

通过运行这段代码并观察 `sizeof` 的输出，我们可以直观地验证这些关于类内存布局和静态成员特性的规则。


*/